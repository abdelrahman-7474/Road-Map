unordered_map<string, unordered_map<string, int>> CountryGraph::FloydWarshall()
{
    // Create a distance map to store all shortest paths
    unordered_map<string, unordered_map<string, int>> distance;

    // Initialize the distance map with the graph data
    for (auto const& city : cities) {
        distance[city.first] = unordered_map<string, int>();
        for (auto const& edge : city.second) {
            distance[city.first][edge.destination_city] = edge.cost;
        }
        // Set distance to self and unvisited cities to infinity
        distance[city.first][city.first] = 0;
        for (auto const& otherCity : cities) {
            if (distance[city.first].count(otherCity.first) == 0) {
                distance[city.first][otherCity.first] = INT_MAX;
            }
        }
    }

    // Relax all edges by considering intermediate vertices
    for (auto const& intermediate_city : cities) {
        for (auto const& source_city : cities) {
            for (auto const& destination_city : cities) {
                // If there's a shorter path through the intermediate vertex, update the distance
                if (distance[source_city.first].count(intermediate_city.first) != 0 &&
                    distance[intermediate_city.first].count(destination_city.first) != 0 &&
                    distance[source_city.first][intermediate_city.first] != INT_MAX &&
                    distance[intermediate_city.first][destination_city.first] != INT_MAX &&
                    distance[source_city.first][intermediate_city.first] + distance[intermediate_city.first][destination_city.first] < distance[source_city.first][destination_city.first]) {
                    distance[source_city.first][destination_city.first] = distance[source_city.first][intermediate_city.first] + distance[intermediate_city.first][destination_city.first];
                }
            }
        }
    }

    return distance;
}

